---
title: Automating Trading Strategies in MQL5 (Part 20): Multi-Symbol Strategy Using CCI and AO
url: https://www.mql5.com/en/articles/18604
categories: Trading, Trading Systems, Expert Advisors
relevance_score: 3
scraped_at: 2026-01-23T17:54:30.632600
---

[Running robots on virtual hosting is easyFollow our step-by-step MetaTrader VPS guide for beginnersRead![](https://www.mql5.com/ff/sh/au4fqg4kms7s9mq1z2/01.png)![](https://www.mql5.com/ff/sh/au4fqg4kms7s9mq1z2/02.png)](https://www.mql5.com/ff/go?link=https://www.mql5.com/en/articles/13586&a=uzpprdshbcrtxvjxpmescehprypbymxc&s=516438f25b531570d9b7d49dcfb29c82fa1021f5ede6571df8026dbfbafcd13f&uid=&ref=https://www.mql5.com/en/articles/18604&id=bfogggabsofabcpxuzmgaibarmaxasdrj&fz_uniq=5068784965589597604)

MetaTrader 5 / Trading


### Introduction

In our [previous article (Part 19)](https://www.mql5.com/en/articles/18298), we explored the [Envelopes](https://www.metatrader5.com/en/terminal/help/indicators/trend_indicators/envelopes "https://www.metatrader5.com/en/terminal/help/indicators/trend_indicators/envelopes") Trend Bounce Scalping Strategy, focusing on trade execution and risk management to complete its automation in [MetaQuotes Language 5](https://www.metaquotes.net/en/metatrader5/algorithmic-trading/mql5 "https://www.metaquotes.net/en/metatrader5/algorithmic-trading/mql5") (MQL5). In Part 20, we introduce a multi-symbol trading strategy that utilizes the [Commodity Channel Index](https://www.metatrader5.com/en/terminal/help/indicators/oscillators/cci "https://www.metatrader5.com/en/terminal/help/indicators/oscillators/cci") (CCI) and [Awesome Oscillator](https://www.metatrader5.com/en/terminal/help/indicators/bw_indicators/awesome "https://www.metatrader5.com/en/terminal/help/indicators/bw_indicators/awesome") (AO) to capture trend reversals across multiple currency pairs. We will cover the following topics:

1. [Strategy Roadmap and Architecture](https://www.mql5.com/en/articles/18604#para1)
2. [Implementation in MQL5](https://www.mql5.com/en/articles/18604#para2)
3. [Backtesting and Optimization](https://www.mql5.com/en/articles/18604#para3)
4. [Conclusion](https://www.mql5.com/en/articles/18604#para4)

By the end, you’ll have a robust MQL5 trading system for multi-symbol trading, ready for optimization and deployment—let’s dive in!

### Strategy Roadmap and Architecture

In Part 19, we built the [Envelopes](https://www.metatrader5.com/en/terminal/help/indicators/trend_indicators/envelopes "https://www.metatrader5.com/en/terminal/help/indicators/trend_indicators/envelopes") Trend Bounce Scalping Strategy, focusing on trade execution and risk management to act on signals generated by price interactions with the Envelopes indicator, confirmed by trend filters. Now, in Part 20, we shift to a multi-symbol trading strategy that uses the Commodity Channel Index (CCI) and Awesome Oscillator (AO) to identify trend reversals across multiple currency pairs on two timeframes (M5 for signals and H1 for trend confirmation). Our roadmap for this article focuses on designing a scalable system that efficiently processes signals, executes trades, and manages risk across multiple symbols.

Our architectural plan emphasizes modularity and robustness, utilizing a class-based structure in MQL5 to organize the strategy’s components. We aim to create a common class that handles indicator calculations (CCI and AO), signal generation based on predefined thresholds, and trade execution with stop-loss and take-profit settings while ensuring no open orders exist for a symbol before placing new trades. This design incorporates safeguards like spread checks and supports trading on new bars or tick-by-tick, providing flexibility for various market conditions, and ultimately delivering a cohesive multi-symbol trading system. In a nutshell, here is what we aim to achieve.

![STRATEGY PLAN](https://c.mql5.com/2/151/Screenshot_2025-06-23_205437.png)

### Implementation in MQL5

To create the program in MQL5, open the [MetaEditor](https://www.metatrader5.com/en/automated-trading/metaeditor "https://www.metatrader5.com/en/automated-trading/metaeditor"), go to the Navigator, locate the Indicators folder, click on the "New" tab, and follow the prompts to create the file. Once it is made, in the coding environment, we will start by declaring some structures and classes that we will use since we want to apply an [Object Oriented Programming](https://www.mql5.com/en/docs/basis/oop) (OOP) approach.

```
//+------------------------------------------------------------------+
//|                                          MultiSymbolCCIAO_EA.mq5 |
//|                           Copyright 2025, Allan Munene Mutiiria. |
//|                                   https://t.me/Forex_Algo_Trader |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Allan Munene Mutiiria."
#property link      "https://t.me/Forex_Algo_Trader"
#property version   "1.00"
#property strict
#property description "Multi-symbol trading strategy using CCI and AO indicators"

#include <Trade/Trade.mqh> //--- Include the Trade library for trading operations

//+------------------------------------------------------------------+
//| Input Parameters Structure                                       | //--- Define a structure for trading parameters
//+------------------------------------------------------------------+
struct TradingParameters {
   string            symbols;                  //--- Store comma-separated symbol list
   int               per_signal_cci;           //--- Set period for CCI signal
   int               per_trend_cci;            //--- Set period for CCI trend
   ENUM_APPLIED_PRICE price_cci;               //--- Specify applied price for CCI
   int               cci_signal_buy_value;     //--- Define CCI buy signal threshold
   int               cci_signal_sell_value;    //--- Define CCI sell signal threshold
   ENUM_TIMEFRAMES   tf_signal;                //--- Set timeframe for signal
   ENUM_TIMEFRAMES   tf_trend;                 //--- Set timeframe for trend
   bool              use_ao_for_trend;         //--- Enable AO for trend confirmation
   int               take;                     //--- Set take-profit in points
   int               stop;                     //--- Set stop-loss in points
   double            lots;                     //--- Specify trade lot size
   int               slip;                     //--- Set maximum slippage
   int               max_spread;               //--- Define maximum allowed spread
   int               magic;                    //--- Set magic number for trades
   bool              trade_anytime;            //--- Allow trading at any time
   string            comment;                  //--- Store trade comment
   int               tester_max_balance;       //--- Set tester balance limit
   bool              debug_mode;               //--- Enable debug mode
};

//+------------------------------------------------------------------+
//| Symbol Data Structure                                            | //--- Define a structure for symbol-specific data
//+------------------------------------------------------------------+
struct SymbolData {
   string            name;                     //--- Store symbol name
   datetime          last_bar_time;            //--- Track last bar timestamp
   int               cci_signal_handle;        //--- Hold CCI signal indicator handle
   int               cci_trend_handle;         //--- Hold CCI trend indicator handle
   int               ao_signal_handle;         //--- Hold AO signal indicator handle
   int               ao_trend_handle;          //--- Hold AO trend indicator handle
   double            cci_signal_data[];        //--- Store CCI signal data
   double            cci_trend_data[];         //--- Store CCI trend data
   double            ao_signal_data[];         //--- Store AO signal data
   double            ao_trend_data[];          //--- Store AO trend data
};
```

We begin the implementation of the multi-symbol [CCI](https://www.metatrader5.com/en/terminal/help/indicators/oscillators/cci "https://www.metatrader5.com/en/terminal/help/indicators/oscillators/cci") and [AO](https://www.metatrader5.com/en/terminal/help/indicators/bw_indicators/awesome "https://www.metatrader5.com/en/terminal/help/indicators/bw_indicators/awesome") trading strategy in MQL5 by setting up the foundational components for robust trade execution. We include the "Trade.mqh" library to enable trading operations through the "CTrade" class, which provides methods for opening and closing positions. This inclusion ensures we have access to essential trading functionality required for executing buy and sell orders across multiple symbols.

Next, we create the "TradingParameters" [structure](https://www.mql5.com/en/docs/basis/types/classes) to organize all input parameters for the strategy. This structure holds critical variables such as "symbols" for the comma-separated list of currency pairs, "per\_signal\_cci" and "per\_trend\_cci" for CCI indicator periods, and "price\_cci" for the applied price type. We also define "cci\_signal\_buy\_value" and "cci\_signal\_sell\_value" to set signal thresholds, "tf\_signal" and "tf\_trend" for timeframes, and risk management variables like "take", "stop", "lots", and "max\_spread". Additionally, "magic" ensures unique trade identification, "trade\_anytime" controls trade timing, and "debug\_mode" enables diagnostic logging, providing a centralized configuration for the strategy.

Finally, we establish the "SymbolData" structure to manage data for each symbol in the trading system. This structure contains "name" for the symbol identifier, "last\_bar\_time" to track the latest bar timestamp, and handles like "cci\_signal\_handle" and "ao\_trend\_handle" for CCI and AO indicators on both signal and trend timeframes. We also include arrays such as "cci\_signal\_data" and "ao\_trend\_data" to store indicator values, enabling efficient data management for multi-symbol processing. These structures lay the groundwork for a modular and scalable trading system. The next thing we need to do is declare a trading class for the control logic.

```
//+------------------------------------------------------------------+
//| Trading Strategy Class                                           | //--- Implement a class for trading strategy logic
//+------------------------------------------------------------------+
class CTradingStrategy {
private:
   CTrade            m_trade;                  //--- Initialize trade object for trading operations
   TradingParameters m_params;                 //--- Store trading parameters
   SymbolData        m_symbols[];              //--- Store array of symbol data
   int               m_array_size;             //--- Track number of symbols
   datetime          m_last_day;               //--- Store last day timestamp
   bool              m_is_new_day;             //--- Indicate new day detection
   int               m_candle_shift;           //--- Set candle shift for signal calculation
   const int         CCI_TREND_BUY_VALUE;      //--- Define constant for CCI trend buy threshold
   const int         CCI_TREND_SELL_VALUE;     //--- Define constant for CCI trend sell threshold
}
```

Here, we implement the core logic of the strategy by creating the "CTradingStrategy" [class](https://www.mql5.com/en/docs/basis/types/classes), which encapsulates all trading functionality in a modular and organized manner. We define [private](https://www.mql5.com/en/book/oop/structs_and_unions/structs_access) member variables to manage the strategy’s state and operations, starting with "m\_trade", an instance of the "CTrade" class from the Trade library, to handle trade execution tasks like opening and closing positions. Next, we include "m\_params", an instance of the "TradingParameters" structure, to store all configuration settings such as symbol lists, indicator periods, and risk parameters, ensuring centralized access to user-defined inputs.

We also declare "m\_symbols", an array of the "SymbolData" [structure](https://www.mql5.com/en/docs/basis/types/classes), to hold data for each symbol, including indicator handles and data buffers, facilitating multi-symbol processing. To track the number of symbols, we use "m\_array\_size", while "m\_last\_day" and "m\_is\_new\_day" manage daily timestamp updates for detecting new trading days. Additionally, we set "m\_candle\_shift" to control whether signals are generated on the current or previous bar, based on the "trade\_anytime" parameter. Finally, we define constants "CCI\_TREND\_BUY\_VALUE" and "CCI\_TREND\_SELL\_VALUE" to establish fixed CCI thresholds for trend confirmation, ensuring consistent signal logic throughout the strategy. We can now include more methods under the private access modifier as below for utility.

```
void PrintDebug(string text) {              //--- Define method to print debug messages
   if(m_params.debug_mode && !MQLInfoInteger(MQL_OPTIMIZATION)) { //--- Check debug mode and optimization status
      Print(text);                          //--- Output debug message
   }
}

void PrintMessage(string text) {            //--- Define method to print informational messages
   if(!MQLInfoInteger(MQL_OPTIMIZATION)) {  //--- Check if not in optimization mode
      Print(text);                          //--- Output message
   }
}

void PrepareSymbolsList() {                 //--- Define method to prepare symbol list
   string symbols_array[];                  //--- Initialize temporary array for symbols
   ushort sep = StringGetCharacter(",", 0); //--- Get comma separator character
   m_array_size = StringSplit(m_params.symbols, sep, symbols_array); //--- Split symbols string into array
   ArrayResize(m_symbols, m_array_size);    //--- Resize symbol data array
   for(int i = 0; i < m_array_size; i++) {  //--- Iterate through symbols
      m_symbols[i].name = symbols_array[i]; //--- Set symbol name
      m_symbols[i].last_bar_time = 0;       //--- Initialize last bar time
      SymbolSelect(m_symbols[i].name, true); //--- Ensure symbol is in market watch
   }
}
```

We implement utility methods within the "CTradingStrategy" class to handle debugging and symbol preparation for the multi-symbol CCI and AO strategy. We create the "PrintDebug" function to output diagnostic messages when "m\_params.debug\_mode" is enabled and the EA is not in optimization mode, using [Print](https://www.mql5.com/en/docs/common/print) to log the "text" parameter for troubleshooting. Similarly, we define the "PrintMessage" function to log informational messages, ensuring output only occurs outside optimization mode by checking " [MQLInfoInteger](https://www.mql5.com/en/docs/check/mqlinfointeger)(MQL\_OPTIMIZATION)" and using "Print" for the "text" input.

Additionally, we develop the "PrepareSymbolsList" function to initialize the symbol data array. We declare a temporary "symbols\_array" to hold the split symbols, use [StringGetCharacter](https://www.mql5.com/en/docs/strings/stringgetcharacter) to get the comma separator for "sep", and apply [StringSplit](https://www.mql5.com/en/docs/strings/StringSplit) to parse "m\_params.symbols" into "symbols\_array". We resize "m\_symbols" using [ArrayResize](https://www.mql5.com/en/docs/array/arrayresize) based on "m\_array\_size" and iterate to set each "m\_symbols\[i\].name" to a symbol, initialize "m\_symbols\[i\].last\_bar\_time" to zero, and call [SymbolSelect](https://www.mql5.com/en/docs/MarketInformation/SymbolSelect) to ensure each symbol is available in the market watch for trading. Next, we need to initialize and update the indicator values.

```
bool InitializeIndicators(int index) {      //--- Define method to initialize indicators
   m_symbols[index].cci_signal_handle = iCCI(m_symbols[index].name, m_params.tf_signal, m_params.per_signal_cci, m_params.price_cci); //--- Create CCI signal indicator
   if(m_symbols[index].cci_signal_handle == INVALID_HANDLE) { //--- Check for invalid handle
      Print("INITIALIZATION OF CCI SIGNAL FAILED: ", m_symbols[index].name); //--- Log error
      return false;                         //--- Return failure
   }
   m_symbols[index].cci_trend_handle = iCCI(m_symbols[index].name, m_params.tf_trend, m_params.per_trend_cci, m_params.price_cci); //--- Create CCI trend indicator
   if(m_symbols[index].cci_trend_handle == INVALID_HANDLE) { //--- Check for invalid handle
      Print("INITIALIZATION OF CCI TREND FAILED: ", m_symbols[index].name); //--- Log error
      return false;                         //--- Return failure
   }
   m_symbols[index].ao_signal_handle = iAO(m_symbols[index].name, m_params.tf_signal); //--- Create AO signal indicator
   if(m_symbols[index].ao_signal_handle == INVALID_HANDLE) { //--- Check for invalid handle
      Print("INITIALIZATION OF AO SIGNAL FAILED: ", m_symbols[index].name); //--- Log error
      return false;                         //--- Return failure
   }
   m_symbols[index].ao_trend_handle = iAO(m_symbols[index].name, m_params.tf_trend); //--- Create AO trend indicator
   if(m_symbols[index].ao_trend_handle == INVALID_HANDLE) { //--- Check for invalid handle
      Print("INITIALIZATION OF AO TREND FAILED: ", m_symbols[index].name); //--- Log error
      return false;                         //--- Return failure
   }
   ArraySetAsSeries(m_symbols[index].cci_signal_data, true); //--- Set CCI signal data as series
   ArraySetAsSeries(m_symbols[index].cci_trend_data, true); //--- Set CCI trend data as series
   ArraySetAsSeries(m_symbols[index].ao_signal_data, true); //--- Set AO signal data as series
   ArraySetAsSeries(m_symbols[index].ao_trend_data, true); //--- Set AO trend data as series
   return true;                             //--- Return success
}

bool UpdateIndicatorData(int index) {       //--- Define method to update indicator data
   if(CopyBuffer(m_symbols[index].cci_signal_handle, 0, 0, 3, m_symbols[index].cci_signal_data) < 3) { //--- Copy CCI signal data
      Print("UNABLE TO COPY CCI SIGNAL DATA: ", m_symbols[index].name); //--- Log error
      return false;                         //--- Return failure
   }
   if(CopyBuffer(m_symbols[index].cci_trend_handle, 0, 0, 3, m_symbols[index].cci_trend_data) < 3) { //--- Copy CCI trend data
      Print("UNABLE TO COPY CCI TREND DATA: ", m_symbols[index].name); //--- Log error
      return false;                         //--- Return failure
   }
   if(CopyBuffer(m_symbols[index].ao_signal_handle, 0, 0, 3, m_symbols[index].ao_signal_data) < 3) { //--- Copy AO signal data
      Print("UNABLE TO COPY AO SIGNAL DATA: ", m_symbols[index].name); //--- Log error
      return false;                         //--- Return failure
   }
   if(CopyBuffer(m_symbols[index].ao_trend_handle, 0, 0, 3, m_symbols[index].ao_trend_data) < 3) { //--- Copy AO trend data
      Print("UNABLE TO COPY AO TREND DATA: ", m_symbols[index].name); //--- Log error
      return false;                         //--- Return failure
   }
   return true;                             //--- Return success
}
```

Here, we implement indicator setup and updates in the "CTradingStrategy" class. We create the "InitializeIndicators" function to set "m\_symbols\[index\].cci\_signal\_handle" and "m\_symbols\[index\].cci\_trend\_handle" using the [iCCI](https://www.mql5.com/en/docs/indicators/icci) function, and "m\_symbols\[index\].ao\_signal\_handle" and "m\_symbols\[index\].ao\_trend\_handle" using the [iAO](https://www.mql5.com/en/docs/indicators/iao) function for a symbol at "index", logging errors with "Print" if handles are [INVALID\_HANDLE](https://www.mql5.com/en/docs/constants/namedconstants/otherconstants). We configure data arrays as time series with [ArraySetAsSeries](https://www.mql5.com/en/docs/array/arraysetasseries).

We also develop the "UpdateIndicatorData" function to copy three data points into "m\_symbols\[index\].cci\_signal\_data", "m\_symbols\[index\].cci\_trend\_data", "m\_symbols\[index\].ao\_signal\_data", and "m\_symbols\[index\].ao\_trend\_data" using the [CopyBuffer](https://www.mql5.com/en/docs/series/copybuffer) function, logging errors with "Print" if insufficient data is retrieved. Next, we need to do an order count so we can track the position's threshold.

```
int CountOrders(string symbol, int magic, ENUM_POSITION_TYPE type) { //--- Define method to count orders
   int count = 0;                           //--- Initialize order counter
   for(int i = PositionsTotal() - 1; i >= 0; i--) { //--- Iterate through positions
      ulong ticket = PositionGetTicket(i);   //--- Get position ticket
      if(PositionSelectByTicket(ticket)) {   //--- Select position by ticket
         if(PositionGetInteger(POSITION_MAGIC) == magic && //--- Check magic number
            PositionGetString(POSITION_SYMBOL) == symbol && //--- Check symbol
            PositionGetInteger(POSITION_TYPE) == type) { //--- Check position type
            count++;                        //--- Increment counter
         }
      }
   }
   return count;                            //--- Return order count
}

long OpenOrder(string symbol, ENUM_ORDER_TYPE type, double price, double sl, double tp, double lots, int magic, string comment) { //--- Define method to open orders
   long ticket = m_trade.PositionOpen(symbol, type, lots, price, sl, tp, comment); //--- Execute position open
   if(ticket < 0) {                         //--- Check for order failure
      PrintMessage(StringFormat("Info - OrderSend %s %d_%s_%.5f error %.5f_%.5f_%.5f_#%d", //--- Log error
         comment, type, symbol, price, price, sl, tp, GetLastError()));
   } else {                                 //--- Handle successful order
      PrintMessage(StringFormat("Info - OrderSend done. Comment:%s, Type:%d, Sym:%s, Price:%.5f, SL:%.5f, TP:%.5f", //--- Log success
         comment, type, symbol, price, sl, tp));
   }
   return ticket;                           //--- Return order ticket
}
```

Here, we implement trade management functions within the "CTradingStrategy" class to handle order counting and execution. We create the "CountOrders" function to tally open positions for a given "symbol" and "magic" number of type [ENUM\_POSITION\_TYPE](https://www.mql5.com/en/docs/constants/tradingconstants/positionproperties#enum_position_type). We initialize "count" to zero, iterate through positions using "PositionsTotal" and [PositionGetTicket](https://www.mql5.com/en/docs/trading/positiongetticket), and use [PositionSelectByTicket](https://www.mql5.com/en/docs/trading/positionselectbyticket) to check if "PositionGetInteger(POSITION\_MAGIC)", "PositionGetString(POSITION\_SYMBOL)", and "PositionGetInteger(POSITION\_TYPE)" match the inputs, incrementing "count" for matches before returning it.

We also develop the "OpenOrder" function to execute trades for a specified "symbol" and "type" with parameters for "price", "sl" (stop-loss), "tp" (take-profit), "lots", "magic", and "comment". We call "m\_trade.PositionOpen" to open the position, storing the result in "ticket", and use "PrintMessage" with [StringFormat](https://www.mql5.com/en/docs/convert/stringformat) to log errors if "ticket" is negative, including [GetLastError](https://www.mql5.com/en/docs/check/getlasterror), or log success details if the order is placed, returning "ticket" for tracking. With that being done, we can define a public class from which we can initialize the members.

```
public:
   CTradingStrategy() : CCI_TREND_BUY_VALUE(-114), CCI_TREND_SELL_VALUE(134) { //--- Initialize constructor with constants
      m_last_day = 0;                          //--- Set initial last day
      m_is_new_day = true;                     //--- Set new day flag
      m_array_size = 0;                        //--- Set initial array size
   }

   bool Init() {                               //--- Define initialization method
      m_params.symbols = "EURUSDm,GBPUSDm,AUDUSDm"; //--- Set default symbols
      m_params.per_signal_cci = 20;            //--- Set CCI signal period
      m_params.per_trend_cci = 24;             //--- Set CCI trend period
      m_params.price_cci = PRICE_TYPICAL;      //--- Set CCI applied price
      m_params.cci_signal_buy_value = -90;     //--- Set CCI buy signal threshold
      m_params.cci_signal_sell_value = 130;    //--- Set CCI sell signal threshold
      m_params.tf_signal = PERIOD_M5;          //--- Set signal timeframe
      m_params.tf_trend = PERIOD_H1;           //--- Set trend timeframe
      m_params.use_ao_for_trend = false;       //--- Disable AO trend by default
      m_params.take = 200;                     //--- Set take-profit
      m_params.stop = 300;                     //--- Set stop-loss
      m_params.lots = 0.01;                    //--- Set lot size
      m_params.slip = 5;                       //--- Set slippage
      m_params.max_spread = 20;                //--- Set maximum spread
      m_params.magic = 123456789;              //--- Set magic number
      m_params.trade_anytime = false;          //--- Disable trade anytime
      m_params.comment = "EA_AO_BP";           //--- Set trade comment
      m_params.tester_max_balance = 0;         //--- Set tester balance limit
      m_params.debug_mode = false;             //--- Disable debug mode

      m_candle_shift = m_params.trade_anytime ? 0 : 1; //--- Set candle shift based on trade mode
      m_trade.SetExpertMagicNumber(m_params.magic); //--- Set magic number for trade object

      PrepareSymbolsList();                    //--- Prepare symbol list
      for(int i = 0; i < m_array_size; i++) {  //--- Iterate through symbols
         if(!InitializeIndicators(i)) {         //--- Initialize indicators
            return false;                      //--- Return failure on error
         }
      }
      PrintMessage("Current Spread on " + Symbol() + ": " + //--- Log current spread
         IntegerToString((int)SymbolInfoInteger(Symbol(), SYMBOL_SPREAD)));
      return true;                             //--- Return success
   }
```

In the public access modifier, we implement the initialization logic. We define the constructor "CTradingStrategy" to initialize "CCI\_TREND\_BUY\_VALUE" and "CCI\_TREND\_SELL\_VALUE" as constants set to -114 and 134, respectively, and set "m\_last\_day" to zero, "m\_is\_new\_day" to true, and "m\_array\_size" to zero for initial state management.

We also create the "Init" function to configure the strategy’s parameters and resources. We assign default values to "m\_params" members, including "m\_params.symbols" for currency pairs, "m\_params.per\_signal\_cci" and "m\_params.per\_trend\_cci" for CCI periods, "m\_params.price\_cci" as "PRICE\_TYPICAL", and thresholds like "m\_params.cci\_signal\_buy\_value" and "m\_params.cci\_signal\_sell\_value".

We set "m\_params.tf\_signal" to [PERIOD\_M5](https://www.mql5.com/en/docs/constants/chartconstants/enum_timeframes), "m\_params.tf\_trend" to "PERIOD\_H1", and risk parameters such as "m\_params.take", "m\_params.stop", and "m\_params.lots". We configure "m\_candle\_shift" based on "m\_params.trade\_anytime", call "m\_trade.SetExpertMagicNumber" with "m\_params.magic", and invoke "PrepareSymbolsList" to set up symbols. We iterate through "m\_array\_size" to call "InitializeIndicators" for each symbol, returning "false" on failure, and log the current spread using "PrintMessage" before returning "true" for success.

Finally, after initializing everything, we can define the [OnTick](https://www.mql5.com/en/docs/event_handlers/ontick) event handler within our class still so that we can only call the method inside the actual event handler. That is why it needs to be public here. You can also set it as virtual but for now, we will keep things simple.

```
void OnTick() {                             //--- Define tick handling method
   datetime new_day = iTime(Symbol(), PERIOD_D1, 0); //--- Get current day timestamp
   m_is_new_day = (m_last_day != new_day);  //--- Check for new day
   if(m_is_new_day) {                       //--- Handle new day
      m_last_day = new_day;                 //--- Update last day
   }

   for(int i = 0; i < m_array_size; i++) {  //--- Iterate through symbols
      bool is_new_bar = false;              //--- Initialize new bar flag
      bool buy_signal = false, sell_signal = false; //--- Initialize signal flags
      bool buy_trend = false, sell_trend = false; //--- Initialize trend flags

      datetime new_time = iTime(m_symbols[i].name, m_params.tf_signal, 0); //--- Get current bar time
      if(!m_params.trade_anytime && m_symbols[i].last_bar_time != new_time) { //--- Check for new bar
         is_new_bar = true;                 //--- Set new bar flag
         m_symbols[i].last_bar_time = new_time; //--- Update last bar time
      }

      if(!UpdateIndicatorData(i)) continue; //--- Update indicators, skip on failure

      double ask = SymbolInfoDouble(m_symbols[i].name, SYMBOL_ASK); //--- Get ask price
      double bid = SymbolInfoDouble(m_symbols[i].name, SYMBOL_BID); //--- Get bid price
      double point = SymbolInfoDouble(m_symbols[i].name, SYMBOL_POINT); //--- Get point value
      long spread = SymbolInfoInteger(Symbol(), SYMBOL_SPREAD); //--- Get current spread

      int total_orders = CountOrders(m_symbols[i].name, m_params.magic, POSITION_TYPE_BUY) + //--- Count buy orders
                        CountOrders(m_symbols[i].name, m_params.magic, POSITION_TYPE_SELL); //--- Count sell orders

      // Generate signals
      buy_signal = m_symbols[i].cci_signal_data[m_candle_shift+1] < m_params.cci_signal_buy_value && //--- Check CCI buy signal condition
                  m_symbols[i].cci_signal_data[m_candle_shift] > m_params.cci_signal_buy_value && //--- Confirm CCI buy signal
                  m_symbols[i].ao_signal_data[m_candle_shift+1] < m_symbols[i].ao_signal_data[m_candle_shift]; //--- Confirm AO buy signal

      sell_signal = m_symbols[i].cci_signal_data[m_candle_shift+1] > m_params.cci_signal_sell_value && //--- Check CCI sell signal condition
                   m_symbols[i].cci_signal_data[m_candle_shift] < m_params.cci_signal_sell_value && //--- Confirm CCI sell signal
                   m_symbols[i].ao_signal_data[m_candle_shift+1] > m_symbols[i].ao_signal_data[m_candle_shift]; //--- Confirm AO sell signal

      buy_trend = m_symbols[i].cci_trend_data[m_candle_shift+1] < m_symbols[i].cci_signal_data[m_candle_shift] && //--- Check CCI trend buy condition
                 m_symbols[i].cci_trend_data[m_candle_shift] > CCI_TREND_BUY_VALUE && //--- Confirm CCI trend buy threshold
                 m_symbols[i].cci_trend_data[m_candle_shift] < CCI_TREND_SELL_VALUE && //--- Confirm CCI trend sell threshold
                 (!m_params.use_ao_for_trend || //--- Check AO trend condition
                  (m_symbols[i].ao_trend_data[m_candle_shift+1] < m_symbols[i].ao_trend_data[m_candle_shift])); //--- Confirm AO trend buy

      sell_trend = m_symbols[i].cci_trend_data[m_candle_shift+1] > m_symbols[i].cci_signal_data[m_candle_shift] && //--- Check CCI trend sell condition
                  m_symbols[i].cci_trend_data[m_candle_shift] > CCI_TREND_BUY_VALUE && //--- Confirm CCI trend buy threshold
                  m_symbols[i].cci_trend_data[m_candle_shift] < CCI_TREND_SELL_VALUE && //--- Confirm CCI trend sell threshold
                  (!m_params.use_ao_for_trend || //--- Check AO trend condition
                   (m_symbols[i].ao_trend_data[m_candle_shift+1] > m_symbols[i].ao_trend_data[m_candle_shift])); //--- Confirm AO trend sell

      // Execute trades
      if(spread < m_params.max_spread && total_orders == 0 && //--- Check spread and open orders
         (m_params.trade_anytime || is_new_bar)) { //--- Check trade timing
         if(buy_signal && buy_trend) {         //--- Check buy conditions
            double sl = m_params.stop == 0 ? 0 : ask - m_params.stop * point; //--- Calculate stop-loss
            double tp = m_params.take == 0 ? 0 : ask + m_params.take * point; //--- Calculate take-profit
            OpenOrder(m_symbols[i].name, ORDER_TYPE_BUY, ask, sl, tp, m_params.lots, //--- Open buy order
                     m_params.magic, "Open BUY " + m_params.comment);
         }
         if(sell_signal && sell_trend) {       //--- Check sell conditions
            double sl = m_params.stop == 0 ? 0 : bid + m_params.stop * point; //--- Calculate stop-loss
            double tp = m_params.take == 0 ? 0 : bid - m_params.take * point; //--- Calculate take-profit
            OpenOrder(m_symbols[i].name, ORDER_TYPE_SELL, bid, sl, tp, m_params.lots, //--- Open sell order
                     m_params.magic, "Open SELL " + m_params.comment);
         }
      }

      // Debug output
      if((m_params.trade_anytime || is_new_bar) && (buy_signal || sell_signal)) { //--- Check debug conditions
         PrintDebug(StringFormat("Debug - IsNewBar: %b - candle_shift: %d - buy_signal: %b - " //--- Log debug information
                               "sell_signal: %b - buy_trend: %b - sell_trend: %b",
                               is_new_bar, m_candle_shift, buy_signal, sell_signal,
                               buy_trend, sell_trend));
      }
   }
}
```

Here, we implement the trading logic for the multi-symbol CCI and AO strategy by creating the [OnTick](https://www.mql5.com/en/docs/event_handlers/ontick) function in the "CTradingStrategy" class. We retrieve the current day’s timestamp with [iTime](https://www.mql5.com/en/docs/series/itime) into "new\_day" and update "m\_is\_new\_day" and "m\_last\_day" to track daily changes. For each symbol in "m\_array\_size", we initialize "is\_new\_bar", "buy\_signal", "sell\_signal", "buy\_trend", and "sell\_trend" flags, and use "iTime" to detect new bars, updating "m\_symbols\[i\].last\_bar\_time" if "m\_params.trade\_anytime" is false.

We call "UpdateIndicatorData" to refresh indicators, skipping on failure, and fetch "ask", "bid", "point", and "spread" with [SymbolInfoDouble](https://www.mql5.com/en/docs/marketinformation/symbolinfodouble) and [SymbolInfoInteger](https://www.mql5.com/en/docs/marketinformation/symbolinfointeger). We compute "total\_orders" using "CountOrders" for buy and sell positions. We set "buy\_signal" by checking "m\_symbols\[i\].cci\_signal\_data" against "m\_params.cci\_signal\_buy\_value" and "m\_symbols\[i\].ao\_signal\_data" for confirmation, and "sell\_signal" with "m\_params.cci\_signal\_sell\_value". We determine "buy\_trend" and "sell\_trend" using "m\_symbols\[i\].cci\_trend\_data", "CCI\_TREND\_BUY\_VALUE", "CCI\_TREND\_SELL\_VALUE", and optionally "m\_symbols\[i\].ao\_trend\_data".

If "spread" is below "m\_params.max\_spread", "total\_orders" is zero, and trading is allowed, we calculate "sl" and "tp" using "m\_params.stop" and "m\_params.take", then call "OpenOrder" for buy or sell trades. We log signal states with "PrintDebug" and [StringFormat](https://www.mql5.com/en/docs/convert/stringformat) when debugging is triggered, ensuring effective trade monitoring. To close the positions, we implement this function below.

```
bool CloseAllTrades() {                     //--- Define method to close all trades
   for(int i = PositionsTotal() - 1; i >= 0; i--) { //--- Iterate through positions
      ulong ticket = PositionGetTicket(i);   //--- Get position ticket
      if(PositionSelectByTicket(ticket) &&   //--- Select position
         PositionGetInteger(POSITION_MAGIC) == m_params.magic) { //--- Check magic number
         ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE); //--- Get position type
         if(type == POSITION_TYPE_BUY || type == POSITION_TYPE_SELL) { //--- Check position type
            m_trade.PositionClose(ticket);   //--- Close position
            PrintMessage("Position close " + IntegerToString(ticket)); //--- Log closure
         }
      }
   }
   for(int i = OrdersTotal() - 1; i >= 0; i--) { //--- Iterate through orders
      ulong ticket = OrderGetTicket(i);      //--- Get order ticket
      if(OrderSelect(ticket) && OrderGetInteger(ORDER_MAGIC) == m_params.magic) { //--- Select order and check magic
         ENUM_ORDER_TYPE type = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE); //--- Get order type
         if(type >= ORDER_TYPE_BUY_STOP && type <= ORDER_TYPE_SELL_LIMIT) { //--- Check order type
            m_trade.OrderDelete(ticket);   //--- Delete order
            PrintMessage("Order delete " + IntegerToString(ticket)); //--- Log deletion
         }
      }
   }
   return true;                             //--- Return success
}
```

Here, we implement trade closure functionality for the multi-symbol CCI and AO strategy by creating the "CloseAllTrades" function within the "CTradingStrategy" class. We iterate through all open positions using [PositionsTotal](https://www.mql5.com/en/docs/trading/positionstotal) and retrieve each position’s ticket with [PositionGetTicket](https://www.mql5.com/en/docs/trading/positiongetticket) into "ticket". For each position selected by "PositionSelectByTicket", we verify if "PositionGetInteger(POSITION\_MAGIC)" matches "m\_params.magic", and if "PositionGetInteger(POSITION\_TYPE)" is "POSITION\_TYPE\_BUY" or "POSITION\_TYPE\_SELL", we call "m\_trade.PositionClose" to close it and log the action with "PrintMessage" and [IntegerToString](https://www.mql5.com/en/docs/convert/IntegerToString).

Additionally, we loop through pending orders using [OrdersTotal](https://www.mql5.com/en/docs/trading/orderstotal), obtaining each order’s ticket with "OrderGetTicket" into "ticket". If [OrderSelect](https://www.mql5.com/en/docs/trading/orderselect) succeeds and "OrderGetInteger(ORDER\_MAGIC)" equals "m\_params.magic", we check if [OrderGetInteger](https://www.mql5.com/en/docs/trading/positiongetinteger)(ORDER\_TYPE)" is between "ORDER\_TYPE\_BUY\_STOP" and "ORDER\_TYPE\_SELL\_LIMIT", then use "m\_trade.OrderDelete" to remove the order and log it with "PrintMessage" and "IntegerToString". We return "true" to indicate the successful closure of all relevant trades and orders. And that is all! All we now need to do is use the classes.

```
//+------------------------------------------------------------------+
//| Global Variables and Functions                                   | //--- Define global variables and functions
//+------------------------------------------------------------------+
CTradingStrategy g_strategy;                   //--- Initialize global strategy object

//+------------------------------------------------------------------+
//| Expert Advisor Functions                                         | //--- Define EA core functions
//+------------------------------------------------------------------+
int OnInit() {                                 //--- Define initialization function
   return g_strategy.Init() ? INIT_SUCCEEDED : INIT_FAILED; //--- Initialize strategy and return status
}
```

We finalize the implementation of the multi-symbol CCI and AO strategy by defining global and core Expert Advisor functions. We declare "g\_strategy" as a global instance of the "CTradingStrategy" class to manage all trading operations across symbols, ensuring centralized access to the strategy’s logic and state throughout the EA’s lifecycle.

We also create the "OnInit" function to handle the EA’s initialization. We call the "Init" function of "g\_strategy" to set up parameters, symbols, and indicators, and return [INIT\_SUCCEEDED](https://www.mql5.com/en/docs/basis/function/events#enum_init_retcode) if successful or "INIT\_FAILED" if an error occurs, ensuring proper initialization status for the MetaTrader 5 platform. On initialization, we have the following outcome.

![INIT OF THE EA](https://c.mql5.com/2/151/Screenshot_2025-06-23_223730.png)

From the image, we can see that we have all the data for the 3 symbols that we selected. We can now move on to calling the [OnTick](https://www.mql5.com/en/docs/event_handlers/ontick) event handler to do the heavy lifting and that will be done.

```
//+------------------------------------------------------------------+
//| Expert Advisor Functions                                         | //--- Define EA core functions
//+------------------------------------------------------------------+
int OnInit() {                                                         //--- Define initialization function
   return g_strategy.Init() ? INIT_SUCCEEDED : INIT_FAILED;            //--- Initialize strategy and return status
}

//+------------------------------------------------------------------+
```

We just call the "Init" function of the global "g\_strategy" object, an instance of the "CTradingStrategy" class, to initialize trading parameters, symbol lists, and indicators. We return [INIT\_SUCCEEDED](https://www.mql5.com/en/docs/basis/function/events#enum_init_retcode) if the initialization succeeds or "INIT\_FAILED" if it encounters an error, ensuring the MetaTrader 5 platform receives the appropriate status to proceed or halt execution. Upon compilation, we have the following outcome.

![FINAL TRADES OUTCOME](https://c.mql5.com/2/151/Screenshot_2025-06-23_224605.png)

From the image, we can see that we are able to open trades based on confirmed signals for the respective symbols and manage them individually. The thing that remains is backtesting the program, and that is handled in the next section.

### Backtesting and Optimization

After thorough backtesting, we have the following results.

Backtest graph:

![GRAPH](https://c.mql5.com/2/151/Screenshot_2025-06-24_000048.png)

Backtest report:

![REPORT](https://c.mql5.com/2/151/Screenshot_2025-06-24_000116.png)

### Conclusion

In conclusion, we have developed an MQL5 program that automates the Multi-Symbol [CCI](https://www.metatrader5.com/en/terminal/help/indicators/oscillators/cci "https://www.metatrader5.com/en/terminal/help/indicators/oscillators/cci") and [AO](https://www.metatrader5.com/en/terminal/help/indicators/bw_indicators/awesome "https://www.metatrader5.com/en/terminal/help/indicators/bw_indicators/awesome") Strategy, executing trades across multiple currency pairs using the "CTradingStrategy" class for signal generation with CCI and AO indicators and robust trade management via the "CTrade" library. With modular components alongside risk controls such as spread validation and stop-loss settings, this system offers a scalable framework that you can customize by tweaking parameters or integrating additional filters.

Disclaimer: This article is for educational purposes only. Trading carries significant financial risks, and market volatility may result in losses. Thorough backtesting and careful risk management are crucial before deploying this program in live markets.

By leveraging the skills and concepts presented, you can refine this multi-symbol trading system or adapt its architecture to create new strategies, advancing your expertise in MQL5 algorithmic trading.

**Attached files** \|


[Download ZIP](https://www.mql5.com/en/articles/download/18604.zip "Download all attachments in the single ZIP archive")

[MultiSymbolCCIAO\_EA.mq5](https://www.mql5.com/en/articles/download/18604/multisymbolcciao_ea.mq5 "Download MultiSymbolCCIAO_EA.mq5")(22.21 KB)

**Warning:** All rights to these materials are reserved by MetaQuotes Ltd. Copying or reprinting of these materials in whole or in part is prohibited.

This article was written by a user of the site and reflects their personal views. MetaQuotes Ltd is not responsible for the accuracy of the information presented, nor for any consequences resulting from the use of the solutions, strategies or recommendations described.

#### Other articles by this author

- [MQL5 Trading Tools (Part 12): Enhancing the Correlation Matrix Dashboard with Interactivity](https://www.mql5.com/en/articles/20962)
- [Creating Custom Indicators in MQL5 (Part 5): WaveTrend Crossover Evolution Using Canvas for Fog Gradients, Signal Bubbles, and Risk Management](https://www.mql5.com/en/articles/20815)
- [MQL5 Trading Tools (Part 11): Correlation Matrix Dashboard (Pearson, Spearman, Kendall) with Heatmap and Standard Modes](https://www.mql5.com/en/articles/20945)
- [Creating Custom Indicators in MQL5 (Part 4): Smart WaveTrend Crossover with Dual Oscillators](https://www.mql5.com/en/articles/20811)
- [Building AI-Powered Trading Systems in MQL5 (Part 8): UI Polish with Animations, Timing Metrics, and Response Management Tools](https://www.mql5.com/en/articles/20722)
- [Creating Custom Indicators in MQL5 (Part 3): Multi-Gauge Enhancements with Sector and Round Styles](https://www.mql5.com/en/articles/20719)
- [Creating Custom Indicators in MQL5 (Part 2): Building a Gauge-Style RSI Display with Canvas and Needle Mechanics](https://www.mql5.com/en/articles/20632)

**[Go to discussion](https://www.mql5.com/en/forum/489881)**

![Mastering Log Records (Part 9): Implementing the builder pattern and adding default configurations](https://c.mql5.com/2/151/18602-mastering-log-records-part-logo.png)[Mastering Log Records (Part 9): Implementing the builder pattern and adding default configurations](https://www.mql5.com/en/articles/18602)

This article shows how to drastically simplify the use of the Logify library with the Builder pattern and automatic default configurations. It explains the structure of the specialized builders, how to use them with smart auto-completion, and how to ensure a functional log even without manual configuration. It also covers tweaks for MetaTrader 5 build 5100.

![Self Optimizing Expert Advisors in MQL5 (Part 8): Multiple Strategy Analysis (2)](https://c.mql5.com/2/152/18471-self-optimizing-expert-advisors-logo.png)[Self Optimizing Expert Advisors in MQL5 (Part 8): Multiple Strategy Analysis (2)](https://www.mql5.com/en/articles/18471)

Join us for our follow-up discussion, where we will merge our first two trading strategies into an ensemble trading strategy. We shall demonstrate the different schemes possible for combining multiple strategies and also how to exercise control over the parameter space, to ensure that effective optimization remains possible even as our parameter size grows.

![Volumetric neural network analysis as a key to future trends](https://c.mql5.com/2/101/Trading_Analysis_with_LSTM_Volume_as_a_Key_to_Future_Trends__LOGO__2.png)[Volumetric neural network analysis as a key to future trends](https://www.mql5.com/en/articles/16062)

The article explores the possibility of improving price forecasting based on trading volume analysis by integrating technical analysis principles with LSTM neural network architecture. Particular attention is paid to the detection and interpretation of anomalous volumes, the use of clustering and the creation of features based on volumes and their definition in the context of machine learning.

![Fast trading strategy tester in Python using Numba](https://c.mql5.com/2/101/Fast_Trading_Strategy_Tester_in_Python_Using_Numba__LOGO.png)[Fast trading strategy tester in Python using Numba](https://www.mql5.com/en/articles/14895)

The article implements a fast strategy tester for machine learning models using Numba. It is 50 times faster than the pure Python strategy tester. The author recommends using this library to speed up mathematical calculations, especially the ones involving loops.

[![](https://www.mql5.com/ff/sh/0hvxp984jjj79943z2/6373d9e5710a718ffa6a7d50a5db9dd1.jpg)\\
Web terminal on your iPhone or Android\\
\\
Full-featured MetaTrader 5 platform for any devices and web browsers\\
\\
Learn more](https://www.mql5.com/ff/go?link=https://trade.metatrader5.com/&a=uyigsjnbfcdvysiynusmriwvhincciwd&s=c95531ae2fd8a81b0fac3def2e4cf820a67584bbf4b02f76ec75f808942dbbd2&uid=&ref=https://www.mql5.com/en/articles/18604&id=wdausxxqrpvhekbwjrjlhqjghyhesrqqau&fz_uniq=5068784965589597604)

![MQL5 - Language of trade strategies built-in the MetaTrader 5 client terminal](https://c.mql5.com/i/registerlandings/logo-2.png)

You are missing trading opportunities:

- Free trading apps
- Over 8,000 signals for copying
- Economic news for exploring financial markets

RegistrationLog in

latin characters without spaces

a password will be sent to this email

An error occurred


- [Log in With Google](https://www.mql5.com/en/auth_oauth2?provider=Google&amp;return=popup&amp;reg=1)

You agree to [website policy](https://www.mql5.com/en/about/privacy) and [terms of use](https://www.mql5.com/en/about/terms)

If you do not have an account, please [register](https://www.mql5.com/en/auth_register)

Allow the use of cookies to log in to the MQL5.com website.

Please enable the necessary setting in your browser, otherwise you will not be able to log in.

[Forgot your login/password?](https://www.mql5.com/en/auth_forgotten?return=popup)

- [Log in With Google](https://www.mql5.com/en/auth_oauth2?provider=Google&amp;return=popup)

This website uses cookies. Learn more about our [Cookies Policy](https://www.mql5.com/en/about/cookies).