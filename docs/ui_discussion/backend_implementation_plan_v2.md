# Backend "Bridge the Gap" Implementation Plan (v2)

**Objective:** Implement the missing backend assets required to support the "Hybrid Risk" architecture and "Shared Asset Library" User Stories.

**Target Audience:** Coding Agent / Backend Engineer.

---

## üèóÔ∏è component 1: The Shared Asset Library (`QuantMind_Risk.mqh`)

**Context:**
This library is NOT just a math calculator. It is a **Data Access Layer (DAO)** that connects MQL5 EAs to the centralized "Risk Matrix" generated by the Python Engine.

**Location:** `extensions/mql5_library/Include/QuantMind/Risk.mqh`

### 1.1 Responsibilities
1.  **Read Global State:** Check `GlobalVariableGet("QM_RISK_MULTIPLIER")`.
2.  **Read Hybrid State (Fallback):** Read `~/.wine/.../Common/Files/risk_matrix.json`.
3.  **Provide Clean Interface:** Expose `GetRiskMultiplier(symbol)` so EAs don't know *how* it's fetched.

### 1.2 Implementation Details (MQL5)
```cpp
// QuantMind_Risk.mqh
#include <Json.mqh> // Use standard MQL5 JSON parser if available, or simple string parsing

class CQuantMindRisk {
private:
    string m_symbol;
    double m_last_multiplier;
    datetime m_last_sync;

    double ReadFileRisk() {
        // Logic to read "Common/Files/risk_matrix.json"
        // Return multiplier for m_symbol
    }

public:
    CQuantMindRisk(string symbol) { m_symbol = symbol; }

    double GetRiskMultiplier() {
        // 1. Try Global Variable (Fastest - Scalper Mode)
        if (GlobalVariableCheck("QM_RISK_" + m_symbol)) {
            return GlobalVariableGet("QM_RISK_" + m_symbol);
        }
        // 2. Fallback to File (Swing Mode)
        return ReadFileRisk();
    }
    
    bool IsChaotic() {
        return GetRiskMultiplier() < 0.5;
    }
};
```

---

## üõ†Ô∏è Component 2: The Indicator Writer Skill

**Context:**
The User wants `QuantCode` (the agent) to be able to **write MQL5 indicators** on demand. This requires a "Skill Definition" that teaches the LLM *how* to write high-performance MQL5.

**Location:** `extensions/coder/skills/indicator_writer/SKILL.md`

### 2.1 The "Ring Buffer" Pattern
We must enforce the **Ring Buffer** pattern (from `mql5_cookbook_...` article) to ensure O(1) calculation speed.

### 2.2 Skill Definition Content (`SKILL.md`)
*   **Role:** You are an Expert MQL5 Developer.
*   **Constraints:**
    *   ALWAYS use `OnCalculate` with `prev_calculated`.
    *   NEVER use `iCustom` inside a loop (Performance Killer).
    *   USE "Ring Buffer" logic for sliding windows (Moving Averages, etc.).
*   **Template:** Provide a robust `OnCalculate` boilerplate.

---

## üîÑ Component 3: The Hybrid Sync (DiskSyncer)

**Context:**
The `StrategyRouter` (Python) needs to push risk updates to the file system so the `@swing` bots (using Component 1) can read them.

**Location:** `src/router/sync.py`

### 3.1 Class Structure
```python
class DiskSyncer:
    def __init__(self, file_path: str):
         self.path = file_path

    def sync(self, risk_matrix: dict):
        """
        Writes the risk matrix to JSON.
        Format: {"EURUSD": {"multiplier": 1.0, "state": "STABLE"}}
        """
        # Atomic write implementation
```
### 3.2 Integration
Update `src/router/engine.py` to initialize `DiskSyncer` and call `sync()` whenever the `PhysicsEngine` produces a new state.

---

## üß™ Verification Steps

1.  **Risk Library:** Create a "Dummy EA" (`TestRisk.mq5`) that includes `QuantMind_Risk.mqh` and prints the multiplier.
2.  **DiskSyncer:** Run a script that writes to the file, then verify `TestRisk.mq5` reads the new value.
3.  **Skill:** Generate a "Simple Moving Average" using the `indicator_writer` skill and verify it compiles.
