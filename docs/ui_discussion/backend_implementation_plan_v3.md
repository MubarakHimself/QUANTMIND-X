# Backend "Bridge the Gap" Implementation Plan (v3)

**Objective:** Implement the missing backend assets required to support the "Hybrid Risk" architecture and "Shared Asset Library" User Stories.

**Target Audience:** Coding Agent / Backend Engineer.

---

## üèóÔ∏è Component 1: The Shared Asset Library (`QuantMind_Risk.mqh`)

**Context:**
This library is NOT just a math calculator. It is a **Data Access Layer (DAO)** that connects MQL5 EAs to the centralized "Risk Matrix" generated by the Python Engine.

**Location:** `extensions/mql5_library/Include/QuantMind/Risk.mqh`

### 1.1 Responsibilities
1.  **Read Global State:** Check `GlobalVariableGet("QM_RISK_MULTIPLIER")`.
2.  **Read Hybrid State (Fallback):** Read `~/.wine/.../Common/Files/risk_matrix.json`.
3.  **Provide Clean Interface:** Expose `GetRiskMultiplier(symbol)` so EAs don't know *how* it's fetched.

### 1.2 Implementation Details (MQL5)
```cpp
// QuantMind_Risk.mqh
#include <Json.mqh> // Use standard MQL5 JSON parser if available, or simple string parsing

class CQuantMindRisk {
private:
    string m_symbol;
    double m_last_multiplier;
    datetime m_last_sync;

    double ReadFileRisk() {
        // Logic to read "Common/Files/risk_matrix.json"
        // Return multiplier for m_symbol
    }

public:
    CQuantMindRisk(string symbol) { m_symbol = symbol; }

    double GetRiskMultiplier() {
        // 1. Try Global Variable (Fastest - Scalper Mode)
        if (GlobalVariableCheck("QM_RISK_" + m_symbol)) {
            return GlobalVariableGet("QM_RISK_" + m_symbol);
        }
        // 2. Fallback to File (Swing Mode)
        return ReadFileRisk();
    }
    
    bool IsChaotic() {
        return GetRiskMultiplier() < 0.5;
    }
};
```

---

## üõ†Ô∏è Component 2: The Indicator Writer Skill

**Architecture:**
Skills are **First-Class Objects** in `src/agents/skills/skill_schema.py`. You must define the skill using the `SkillDefinition` Pydantic model.

**Location:** `src/agents/skills/trading_skills/indicator_writer.py`

### 2.1 Skill Definition
```python
from src.agents.skills.skill_schema import SkillDefinition

indicator_writer_skill = SkillDefinition(
    name="indicator_writer",
    category="trading_skills",
    version="1.0.0",
    description="Generates high-performance MQL5 custom indicators using the Ring Buffer pattern.",
    input_schema={
        "type": "object",
        "properties": {
            "indicator_name": {"type": "string"},
            "formula": {"type": "string"},
            "buffers": {"type": "integer"}
        },
        "required": ["indicator_name", "formula"]
    },
    output_schema={
        "type": "object",
        "properties": {
            "mql5_code": {"type": "string"},
            "file_name": {"type": "string"}
        }
    },
    system_prompt_addition="""
    You are an MQL5 Optimization Expert.
    RULES:
    1. ALWAYS use the 'Ring Buffer' pattern for sliding windows.
    2. NEVER use iCustom inside loops.
    3. Use 'prev_calculated' for incremental updates.
    """,
    code="...", # Python code to register/execute the generation
    example_usage="generate_indicator(name='SuperTrend', formula='...')"
)
```

### 2.2 The "Ring Buffer" Pattern
In the `code` or `system_prompt_addition`, strictly reference the `CRiBuffDbl` class pattern found in `data/scraped_articles/integration/mql5_cookbook_-_creating_a_ring_buffer...`.

---

## üîÑ Component 3: The Hybrid Sync (DiskSyncer)

**Context:**
The `StrategyRouter` (Python) needs to push risk updates to the file system so the `@swing` bots (using Component 1) can read them.

**Location:** `src/router/sync.py`

### 3.1 Class Structure
```python
class DiskSyncer:
    def __init__(self, file_path: str):
         self.path = file_path

    def sync(self, risk_matrix: dict):
        """
        Writes the risk matrix to JSON.
        Format: {"EURUSD": {"multiplier": 1.0, "state": "STABLE"}}
        """
        # Atomic write implementation
```
### 3.2 Integration
Update `src/router/engine.py` to initialize `DiskSyncer` and call `sync()` whenever the `PhysicsEngine` produces a new state.

---

## üåê Component 4: Future MCP Integration

**Strategy:**
Since `SkillDefinition` is a standard schema, we can easily expose these skills via MCP.
*   **Plan:** Create a generic `SkillMCPServer` that iterates through the `SkillRegistry` and converts each `SkillDefinition` into an MCP Tool.
*   **Benefit:** This makes `indicator_writer` available to *any* MCP-compliant client (like Claude Desktop or other Agents) without code changes.

---

## üß™ Verification Steps

1.  **Risk Library:** Create a "Dummy EA" (`TestRisk.mq5`) that includes `QuantMind_Risk.mqh` and prints the multiplier.
2.  **DiskSyncer:** Run a script that writes to the file, then verify `TestRisk.mq5` reads the new value.
3.  **Skill:** Instantiate `indicator_writer_skill` and verify it passes `SkillValidator.validate_skill`.
